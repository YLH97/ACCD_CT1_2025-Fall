<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Sketch</title>

    <link rel="stylesheet" type="text/css" href="style.css">

    <script src="libraries/p5.min.js"></script>
    <script src="libraries/p5.sound.min.js"></script>
  </head>

   <body>
    <h1>Interactive System with UI</h1>

    <h2>Intent</h2>
    <p>
  I built a simple interactive system using object-oriented programming. In this system, multiple pets react to the food I place on the screen. 
  <br>Each pet follows only a few local rules. Even with this simple logic, the system can create visible patterns, such as pets grouping together 
  <br>or changing their movement when food appears.
    </p>

    <h2>Process</h2>

  <h3>Step 1: Build the pet system and basic motion</h3>
    <p>
  First, I created a pet class and spawned multiple pets in the environment. The initial goal was to make the system feel alive by giving each pet its own
      <br>position and velocity. I used small random changes in velocity each frame, which creates a gentle wandering motion over time.
    </p>

    <code>
      <pre>
        this.vx += random(-0.04, 0.04);
        this.vy += random(-0.04, 0.04);
        
        this.x += this.vx;
        this.y += this.vy;
      </pre>
    </code>

    <h3>Step 2: Add a simple relationship to create emergent behavior</h3>
    <p>
  Next, I added a simple relationship between the pets and the food. Each pet moves slightly toward the closest piece of food. The pet does not know what is 
  <br>happening in the whole system. It only reacts to how far the food is from itself. When many pets follow this same rule, group movement and clustering appear 
  <br>naturally, without directly programming group behavior.
    </p>

    <code>
      <pre>
        let dx = closest.x - this.x;
        let dy = closest.y - this.y;

        this.vx += dx * 0.00015;
        this.vy += dy * 0.00015;
      </pre>
    </code>

    <h3>Step 3: Add feedback through collision outcomes</h3>
    <p>
 Finally, I added feedback so the elements in the system can affect each other. When a pet reaches a piece of food, the food disappears and the pet becomes larger. 
 <br>This creates an ongoing cycle: the user adds food, pets move toward it, and the system keeps changing as food is eaten and the pets grow.
    </p>

    <code>
      <pre>
        if (d < this.size / 2 + f.size / 2) {
          f.eaten = true;
          this.size += 3;
        }
      </pre>
    </code>
    <script src="sketch.js"></script>
  </body>
</html>
