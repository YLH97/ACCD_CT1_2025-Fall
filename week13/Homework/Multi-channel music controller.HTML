<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <title>Multi-channel music controller</title>
</head>

<body>
  <h1>Multi-channel music controllerüéµ</h1>

  <section>
    <h2>Step 1  Build the physical controller</h2>
    <p>
      I decided to build a music controller by fixing four buttons and two potentiometers onto a paper box. My first version failed because of poor connections of the wires, they were not making good contact.
      After improving the wiring and connections for both the buttons and the potentiometers, the second version was quite successful.
    </p>

    <div style="display:flex; gap: 8px; max-width:900px;">
        <figure style="flex:1; margin:0;">
            <img src="img/4.jpg" alt="version 1-1" style="width:100%; height:auto;">
            <figcaption>Version 1-1</figcaption>
        </figure>

        <figure style="flex:1; margin:0;">
            <img src="img/5.jpg" alt="version 1-2" style="width:100%; height:auto;">
            <figcaption>Version 1-2</figcaption>
        </figure>
    </div>

    <div style="display:flex; gap: 8px; max-width:900px;">
        <figure style="flex:1; margin:0;">
            <img src="img/2.jpg" alt="version 2-1" style="width:100%; height:auto;">
            <figcaption>Version 2-1</figcaption>
        </figure>

        <figure style="flex:1; margin:0;">
            <img src="img/3.jpg" alt="version 2-2" style="width:100%; height:auto;">
            <figcaption>Version 2-2</figcaption>
        </figure>
    </div>

    <p>The Version 2 is OK, the only issue was the wiring. So later in class, I asked the teacher for additional welding support, which made the connections more stable and reliable.(Thank u Maximü•π)</p>
    <div style="display:flex; gap: 8px; max-width:900px;">
            <figure style="flex:1; margin:0;">
            <img src="img/6.jpg" alt="version 2-2" style="width:50%; height:auto;">
            <figcaption>Version 3</figcaption>
        </figure>
    </div>
  </section>

<section>
    <h2>Step 2  Set up libraries and core structure</h2>
    <p>
      I started by importing the Serial and Sound libraries in Processing. This project needs Serial input from my controller,
      and SoundFile objects to load and loop multiple audio tracks. I also added a helper function <code>knobAngle()</code>
      to convert potentiometer values into rotation angles for the UI knobs.
    </p>

    <code><pre>import processing.serial.*;
import processing.sound.*;

float knobAngle(float v, float vmin, float vmax) {
  float a1 = -PI * 0.75;
  float a2 =  PI * 0.75;
  return map(constrain(v, vmin, vmax), vmin, vmax, a1, a2);
}</pre></code>
  </section>

  <hr />

  <section>
    <h2>Step 3  Load multiple loops and define interaction states</h2>
    <p>
      I loaded four loop files as four separate channels. Each channel can be turned on/off using a physical button.
      The idea is ‚Äúpress once = play, press again = stop‚Äù, I created a toggle state system using two arrays:
      <code>isLooping[]</code> stores whether a channel is currently looping, and <code>lastPressed[]</code> stores the previous button state for edge detection.
    </p>

    <code><pre>// ====== Audio files ======
SoundFile techno1;
SoundFile techno2;
SoundFile techno3;
SoundFile techno4;

// ====== Toggle playback state ======
boolean[] isLooping   = {false, false, false, false}; // currently looping?
boolean[] lastPressed = {false, false, false, false}; // previous button state (for edge detect)

void setup() {
  size(700, 240);

  techno1 = new SoundFile(this, "loop16.WAV");
  techno3 = new SoundFile(this, "loop9.WAV");
  techno4 = new SoundFile(this, "loop10.WAV");
  techno2 = new SoundFile(this, "loop3.WAV");
}</pre></code>

    <p>
      After testing the initial setup, I realized that the physical button order on my device is different compared to my on-screen UI order, so
      I added a mapping table <code>uiToSerial</code>. This allows me to keep the UI layout unchanged while matching real button inputs correctly.
    </p>

    <code><pre>int[] uiToSerial = {3, 2, 1, 0};</pre></code>
  </section>

  <hr />

  <section>
    <h2>Step 4  Build a custom UI (pads + knobs)</h2>
    <p>
      I designed a simple DJ-style interface:
      four circular pads represent the four channels (they glow when the channel is ON),
      two rotary knobs visualize the two potentiometers.
    </p>

    <h3>4.1 Channel pads (glow ON/OFF)</h3>
    <code><pre>// draw pads (4 channels)
for (int i = 0; i &lt; 4; i++) {
  boolean on = isLooping[i];

  noStroke();
  if (on) fill(90, 220, 160, 120);
  else    fill(255, 255, 255, 18);
  ellipse(cx[i] + padSize/2, padY + padSize/2, padSize + 18, padSize + 18);

  if (on) fill(90, 220, 160);
  else    fill(40);
  ellipse(cx[i] + padSize/2, padY + padSize/2, padSize, padSize);

  fill(220);
  textAlign(CENTER, TOP);
  text("CH " + (i+1), cx[i] + padSize/2, padY + padSize + 8);
}</pre></code>

    <h3>4.2 Rotary knobs (potentiometers)</h3>
    <p>
      To draw each knob, I mapped a pot value (0‚Äì4095) into an angle range and drew a pointer line.
      This makes the potentiometer state easy to understand visually.
    </p>

    <code><pre>// pointer angle based on pot value
float ang = knobAngle(v, vmin, vmax);
float px = x + cos(ang) * r * 0.85;
float py = y + sin(ang) * r * 0.85;

stroke(250);
strokeWeight(4);
line(x, y, px, py);</pre></code>
  </section>

  <hr />

  <section>
    <h2>Step 5  Read Serial data, smooth pots, map controls to sound</h2>
    <p>
      In <code>serialEvent()</code>, Processing reads one line at a time, then splits the incoming CSV string.
      The first four values are buttons, and the last two values are potentiometers.
      I apply smoothing to the pot values to reduce noise, then map them to playback rate:
      pot1 controls Group A (CH1 + CH2) and pot2 controls Group B (CH3 + CH4).
    </p>

    <h3>5.1 Parse incoming data</h3>
    <code><pre>String incoming = conn.readStringUntil('\n');
incoming = trim(incoming);
String[] values = split(incoming, ',');
if (values.length &lt; 6) return;</pre></code>

    <h3>5.2 Read buttons + apply mapping</h3>
    <p>
      I store button states into an array, then use <code>uiToSerial</code> to map physical order to UI order.
      This ensures that when I press a real button, the correct UI pad lights up and the correct track toggles.
    </p>

    <code><pre>boolean[] pressed = new boolean[4];
pressed[0] = int(values[0]) == 1;
pressed[1] = int(values[1]) == 1;
pressed[2] = int(values[2]) == 1;
pressed[3] = int(values[3]) == 1;

gateToggle(0, pressed[uiToSerial[0]], techno1);
gateToggle(1, pressed[uiToSerial[1]], techno3);
gateToggle(2, pressed[uiToSerial[2]], techno4);
gateToggle(3, pressed[uiToSerial[3]], techno2);</pre></code>

    <h3>5.3 Smooth potentiometers</h3>
    <code><pre>pot1Raw = constrain(int(values[4]), 0, 4095);
pot2Raw = constrain(int(values[5]), 0, 4095);

pot1Smooth = alpha * pot1Raw + (1 - alpha) * pot1Smooth;
pot2Smooth = alpha * pot2Raw + (1 - alpha) * pot2Smooth;</pre></code>
  </section>

  <hr />

  <section>
    <h2>Step 6  Toggle loop playback (press once ON, press again OFF)</h2>
    <p>
      To avoid repeated triggering while a button is held down, I used edge detection:
      only when the current input is pressed AND the previous input was not pressed, it counts as a ‚Äúnew press‚Äù.
      Then I toggle between <code>loop()</code> and <code>stop()</code>.
    </p>

    <code><pre>void gateToggle(int idx, boolean pressed, SoundFile s) {
  if (pressed && !lastPressed[idx]) {
    if (!isLooping[idx]) {
      s.loop();                 // ON
      isLooping[idx] = true;
    } else {
      s.stop();                 // OFF
      isLooping[idx] = false;
    }
  }
  lastPressed[idx] = pressed;
}</pre></code>
  </section>

  <hr />

  <section>
    <h2>Final Outcome</h2>
    <p>
      In the video, you can see how the buttons control the looping of different audio channels 
      <ul>
        <li>Four buttons toggle four looping tracks (on/off).</li>
        <li>POT1 controls playback rate for CH1 + CH2, POT2 controls playback rate for CH3 + CH4.</li>
        <li>A custom UI shows pads (loop states), knobs (pot values), and other values.</li>
      </ul>
    </p>
    <video src="img/final.mp4" controls style="max-width:300%; height:auto;">
      Your browser does not support the video tag.
    </video>
  </section>
</body>
</html>