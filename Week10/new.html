<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Blinkenlights</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <h1>Blinkenlights</h1>

    <video controls>
      <source src="Homework.mp4" type="video/mp4" />
      Your browser does not support the video tag.
    </video>
    <p class="note">
      Final result: the potentiometer controls the LED blinking speed, and the button simply toggles the LED system on and off.
    </p>

    <h2>Process Documentation</h2>

    <h2>Step 1: Define pins and timing variables</h2>
    <p>
      First, I defined the hardware pins for the LED, button, and potentiometer. Then I created timing variables to track the blinking interval and the last time the LED changed.
      This sets up the structure for controlling LED rhythm using <code>millis()</code>.
    </p>

    <code>
      <pre>
#define LED_PIN 27
#define BUTTON_PIN 13
#define POTENTIOMETER_PIN A2

unsigned long delayBetweenBlink = 500;
unsigned long lastTimeLEDBlinked = 0;
      </pre>
    </code>

    <h2>Step 2: Set up the button with a stable input mode</h2>
    <p>
      Next, I configured the LED pin as an output, and I used <code>INPUT_PULLUP</code> for the button. This lets the button work reliably without needing an external pull-up resistor.
    </p>

    <code>
      <pre>
void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
}
      </pre>
    </code>

    <h2>Step 3: Debounce the button and toggle the system</h2>
    <p>
      Then I added a debounce check to prevent accidental double-triggers caused by mechanical bouncing. When the button is released (state becomes HIGH),
      the system toggles between blinking enabled and disabled.
    </p>

    <code>
      <pre>
unsigned long debounceDuration = 50;
unsigned long lastTimeButtonStateChanged = 0;
byte lastButtonState = HIGH;

bool blinkEnabled = true;

if (timeNow - lastTimeButtonStateChanged > debounceDuration) {
  byte buttonState = digitalRead(BUTTON_PIN);
  if (buttonState != lastButtonState) {
    lastTimeButtonStateChanged = timeNow;
    lastButtonState = buttonState;
    if (buttonState == HIGH) {
      blinkEnabled = !blinkEnabled;
    }
  }
}
      </pre>
    </code>

    <h2>Step 4: Read the potentiometer and map it to a blink interval</h2>
    <p>
      After the button worked, I connected the potentiometer to an analog input and read its value. I mapped the value range to a time interval (in milliseconds).
      This converts turning the knob into changing the LED tempo from fast to slow.
    </p>

    <code>
      <pre>
int potentiometerValue = analogRead(POTENTIOMETER_PIN);
delayBetweenBlink = map(potentiometerValue, 0, 4095, 50, 2000);
      </pre>
    </code>

    <h2>Step 5: Blink the LED using millis timing (no delay)</h2>
    <p>
      Finally, I used <code>millis()</code> to check whether enough time has passed since the last blink. If blinking is enabled,
      the LED toggles between HIGH and LOW. If blinking is disabled, the LED stays off.
    </p>

    <code>
      <pre>
if (blinkEnabled) {
  if (timeNow - lastTimeLEDBlinked > delayBetweenBlink) {
    lastTimeLEDBlinked = timeNow;
    LEDState = (LEDState == HIGH) ? LOW : HIGH;
    digitalWrite(LED_PIN, LEDState);
  }
} else {
  digitalWrite(LED_PIN, LOW);
}
      </pre>
    </code>

    <h2>Full Code (Reference)</h2>
    <p class="note">
      This is the complete version of the code used for the final result.
    </p>

    <code>
      <pre>
#define LED_PIN 27
#define BUTTON_PIN 13
#define POTENTIOMETER_PIN A2

unsigned long delayBetweenBlink = 500;
unsigned long lastTimeLEDBlinked = 0;

unsigned long debounceDuration = 50;
unsigned long lastTimeButtonStateChanged = 0;
byte lastButtonState = HIGH;

bool blinkEnabled = true;
byte LEDState = LOW;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
}

void loop() {
  unsigned long timeNow = millis();

  if (timeNow - lastTimeButtonStateChanged > debounceDuration) {
    byte buttonState = digitalRead(BUTTON_PIN);
    if (buttonState != lastButtonState) {
      lastTimeButtonStateChanged = timeNow;
      lastButtonState = buttonState;
      if (buttonState == HIGH) {
        blinkEnabled = !blinkEnabled;
      }
    }
  }

  int potentiometerValue = analogRead(POTENTIOMETER_PIN);
  delayBetweenBlink = map(potentiometerValue, 0, 4095, 50, 2000);

  if (blinkEnabled) {
    if (timeNow - lastTimeLEDBblinked > delayBetweenBlink) {
      lastTimeLEDBblinked = timeNow;
      LEDState = (LEDState == HIGH) ? LOW : HIGH;
      digitalWrite(LED_PIN, LEDState);
    }
  } else {
    digitalWrite(LED_PIN, LOW);
  }
}
      </pre>
    </code>
  </body>
</html>
